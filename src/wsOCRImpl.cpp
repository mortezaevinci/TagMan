// This file generated by staff_codegen
// For more information please visit: http://code.google.com/p/staff/
// Service Implementation

#include "wsOCRImpl.h"

#include <iostream>
#include <stdio.h>
#include <string.h>

#include <rise/common/StreamBuffer.h>
#include <rise/common/DataEncoder.h>

#include "sqlite3.h"

#include "tesseractapi.h"

#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/highgui/highgui.hpp"

#include "ImageUtils.h"

#include "fileFunctions.h"
#include "myCORE.h"
#include "MyProc.h"
#include "MyBarcode.h"
#include "myRANSAC.h"
#include "myComm.h" //contains sqlite and str encode (strhex for now)
#include "myCompare.h"

#include "consts.h";

const string serverfileAddress="c:\\temp";

wsOCRImpl::wsOCRImpl()
{
} 
 
wsOCRImpl::~wsOCRImpl()
{
}

void wsOCRImpl::OnCreate()
{
  // this function is called when service instance is created and registered
}

void wsOCRImpl::OnDestroy()
{
  // this function is called immediately before service instance destruction
}

double wsOCRImpl::sendClientID(double clientID)
{
  double tResult=0;
  // TODO: place your code here

  return tResult;  // result
}

std::string wsOCRImpl::receiveContent(int linker, int flag)
{
  std::string tResult="";
  // TODO: place your code here

  return tResult;  // result
}

void wsOCRImpl::sendContent(std::string content, int linker, int flag)
{
  // TODO: place your code here
}

void wsOCRImpl::sendFile(std::string fileContentEncoded, std::string fileAddress)
{
  // TODO: place your code here


  // pBuffOut - resulting buffer pointer
 // unsigned long int nOutBuffSize=fileContentEncoded.length();// nOutBuffSize - buffer size
  //char* pBuffOut=new char[nOutBuffSize];
  //rise::CBase64Encoder::Decode(fileContentEncoded, reinterpret_cast<rise::TBuffer*>(pBuffOut), nOutBuffSize);
  //string fileContent=pBuffOut;
	string fileContent=hex2str(fileContentEncoded);
  str2file(fileContent,fileAddress);
}

std::string wsOCRImpl::sendFile(std::string fileContent)
{
  std::string tResult="";
  // TODO: place your code here

  return tResult;  // result
}

int wsOCRImpl::sendFileClient(std::string fileContent)
{
  int tResult=0;
  // TODO: place your code here

  return tResult;  // result
}

std::string wsOCRImpl::receiveFile(std::string fileAddress)
{
  std::string tResult="";
  // TODO: place your code here

  return tResult;  // result
}

void wsOCRImpl::sendFileInfo(std::string filename, std::string fileInfo)
{
  // TODO: place your code here
}

std::string wsOCRImpl::receiveFileInfo(std::string filename)
{
  std::string tResult;
  // TODO: place your code here

  return tResult;  // result
}

void wsOCRImpl::doOCR(std::string fileAddress)
{
  // TODO: place your code here
}

void wsOCRImpl::doOCR(double clientID)
{
  // TODO: place your code here
}

std::string wsOCRImpl::receiveOCR(std::string fileAddress)
{
  std::string tResult;



  tResult= callOCR(fileAddress);


  return str2hex(tResult);  // result
}



std::string wsOCRImpl::perform(std::string AppDataStr)
{
	//initialization
		sqlite3 *db;
		string dbAddress=serverfileAddress+"\\tagman.db";
			  	int error = sqlite3_open(dbAddress.c_str(), &db);
iferr;

	  std::string ocrString;
	  string tResult="";

	//  coutdd(AppDataStr);

	AppData AppData0;

	//get data
	AppData0.Deserialize(AppDataStr);

	//check key
	string checkKey=generateKey(AppData0.clientID);

	coutdd("client is: "<< AppData0.clientID<<","<<AppData0.clientKey<<endl);
	coutdd("correct key is: "<<checkKey<<endl);

	coutdd("key correctness is: "<<checkKey.compare(AppData0.clientKey));

	if (checkKey.compare(AppData0.clientKey)==0)
	{
		coutdd("key is correct."<<endl);
		//export image
	string fileAddressFull=	serverfileAddress+"\\"+AppData0.filenameBase+AppData0.filenameRelative;//+"."+AppData0.filenameExt;
	coutdd("addressFull is " << fileAddressFull<<endl);

	//string fileAddressFull_pre1=	serverfileAddress+"\\"+AppData0.filenameBase+AppData0.filenameRelative+"_pre1.";//+AppData0.filenameExt;
	//coutdd("addressFullPre is "<< fileAddressFull_pre1<<endl);
	str2file(AppData0.file,fileAddressFull+"."+AppData0.filenameExt);

	
	//do preprocess1
	   Mat image;
	       image = imread(fileAddressFull+"."+AppData0.filenameExt, 1);
		   	Mat grayS;

			imwritedd(fileAddressFull+"_image."+AppData0.filenameExt,image); 


	cvtColor(image, grayS, CV_BGR2GRAY);

	coutdd("Image is opened."<<endl);
	imageshow("image",grayS);
				imwritedd(fileAddressFull+"_grays."+AppData0.filenameExt,grayS); 
	//interpolation
	       double resizerate=2; //TODO:use a variable resizerate, and instead make the image size constant

		     Size sSize=grayS.size();

  Mat gray;
  Size gSize=Size((int)(sSize.width*resizerate),(int)(sSize.height*resizerate));

     
 resize(grayS,gray,gSize); //interpolation _end
 imageshow("resized image", gray);
 coutdd("image is resized."<<endl);

 //contrast adjustment   
	
 	 double lowFound, highFound;
	 double lowFloat=1;
	 double highFloat=99;

	 imageshow("0",gray);

     stretchlimits(gray, &lowFound, &highFound, lowFloat/100.0, highFloat/100.0);
     contrastadjust(gray, gray, lowFound, highFound);

	 coutdd("image is adjusted."<<endl);
	 imwritedd(fileAddressFull+"_adjusted."+AppData0.filenameExt,gray); 

	  //nonlinear window-based adjusted binarization 2
		 		 Mat adaptiveCriterionB,adaptiveGrayB;
	 //Criterion represents where important information are located.

	 adaptiveCriterionB.create(gray.size(),gray.type()); //contrast adjustment _end
	 adaptiveGrayB.create(gray.size(),gray.type()); //contrast adjustment _end
	 int MinMaxRadiousSet[3];//={(int)(minmaxR*resizerate),(int)(9*resizerate),(int)(11*resizerate)};
	 for(int i=0;i<3;i++)
	  MinMaxRadiousSet[i]=(int)(minmaxRadiousBase[i]*resizerate);


	 imshowdd("1",gray);

	 adjustedBinary2(gray,adaptiveGrayB,adaptiveCriterionB,MinMaxRadiousSet,Binarization_rangeThresh);
	// imshowdd("2", gray);

	// namedWindow("adjustedBinary2",1);

	// imwrite(fileAddressFull_pre1,gray); //nonlinear window-based adjusted binarization 2 _end
	 imwrite(fileAddressFull+"_pre."+AppData0.filenameExt,adaptiveGrayB); 

	 coutdd("Preprocessing is finished."<<endl);
	 
	 //clean up
	 	image.release();
		 gray.release();
		 grayS.release();
		 adaptiveCriterionB.release();
		 adaptiveGrayB.release();



	//do OCR

	 //TODO: use box version later on, and fix problems in OCR by retesting
	  ocrString= callOCR(fileAddressFull+"."+AppData0.filenameExt);

	  coutdd("OCR is performed. ocr string is: "<< ocrString<<endl);

	  if (ocrString.length()<2)
	  {
		  coutdd("OCR string is too short. Failed detection.");
		  tResult.append("Not a good image. Please redo.\10\13");
		  return str2hex(tResult);
	  }
	  //TODO: compile classified data

	  //TODO: see if product exists in database
	  //(for now, the best AND better than 40% similarity)

	  string db_ocrString, best_db_ocrString;
int db_id, best_db_id;
double rate,best_rate=0;

	  	sqlite3_stmt    *res;

		const char      *tail;

		error = sqlite3_prepare(db,
        "SELECT id,ocrstring FROM ocrdata",
        1000, &res, &tail);

if (error != SQLITE_OK)
    {
    coutdd("no data in db."<<endl);
	best_rate=0;
    }
else
{


while (sqlite3_step(res) == SQLITE_ROW)
    {
		coutdd("getting data...");
		db_id=sqlite3_column_int(res,0);
		coutdd("id is captured...");
        db_ocrString=hex2str(std::string(reinterpret_cast<const char*>(  sqlite3_column_text(res, 1)  )));

		coutdd(db_id<<","<<db_ocrString<<endl);

		rate=strCompare((char *)db_ocrString.c_str(),(char *)ocrString.c_str());

		coutdl("each rate: db id="<<db_id<<" rate="<<rate);

		if (rate>best_rate)
		{
			best_rate=rate;
			best_db_id=db_id;
			best_db_ocrString=db_ocrString;

		}

    }

	sqlite3_finalize(res);

}
coutdl("best rate is ",best_rate);


	if (best_rate>rate_thresh) //similarity better than 40%
	{
	//TODO: if data is old, return product. find product the right way
		coutdd("reporting an existing product."<<endl);

			string best_db_id_str=std::to_string((long double)best_db_id);
		tResult.append("Product found: database ID is ");
		tResult.append(best_db_id_str);
		tResult.append(" string is ");
	}
	else
	{
		coutdd("adding a new product"<<endl);
	  //TODO: if data is new, store ocrString in db. classify data, and store in db
		tResult.append("Product not found! Added to database. string is ");


		//store it in db
		coutdd("adding the product to the database."<<endl);
		string query;
		query.assign("INSERT INTO ocrdata(id,name,filename,ocrstring,ocrclass,knowledgeclass,otherarranged,date,other) VALUES (NULL,\'testing\',\'");
		query.append(str2hex(fileAddressFull+"."+AppData0.filenameExt));
		query.append("\',\'");
		query.append(str2hex(ocrString));
		query.append("\',\'\',\'\',\'\',\'\',\'\')");
		error = sqlite3_exec(db,
    query.c_str(),
    0, 0, 0);
    iferr;

	coutdd("Product added to the database."<<endl);
	}

	  //TODO: show back the results


  // TODO: place your code here


	  tResult.append(ocrString);



	  coutdd("***END***"<<endl);

	  //clean up
	     sqlite3_close (db); 


  return str2hex(tResult);  // result
	}
	else
	{
		
		return str2hex("wrong key");
	}

}
